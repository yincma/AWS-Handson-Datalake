#!/bin/bash

# =============================================================================
# 数据湖兼容性CLI包装器
# 版本: 1.0.0
# 描述: 提供新旧系统的统一接口
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/compatibility.sh"

readonly COMPAT_CLI_VERSION="1.0.0"

# =============================================================================
# 检测系统模式
# =============================================================================

detect_system_mode() {
    # 检查是否已完成迁移
    if grep -q "MIGRATION_COMPLETED=true" "$PROJECT_ROOT/configs/config.env" 2>/dev/null; then
        echo "new"
        return
    fi
    
    # 检查是否存在新系统堆栈
    if check_stack_exists "${PROJECT_PREFIX}-stack-s3-${ENVIRONMENT}" 2>/dev/null; then
        echo "new"
        return
    fi
    
    # 检查是否存在旧系统堆栈
    if check_stack_exists "datalake-s3-storage-${ENVIRONMENT}" 2>/dev/null; then
        echo "legacy"
        return
    fi
    
    # 默认使用新系统
    echo "new"
}

# =============================================================================
# 命令路由
# =============================================================================

route_to_legacy() {
    local command="$1"
    shift
    
    case "$command" in
        deploy)
            export USE_LEGACY_NAMING=true
            "$PROJECT_ROOT/scripts/setup-env.sh" "$@"
            ;;
        cleanup|destroy)
            export USE_LEGACY_NAMING=true
            "$PROJECT_ROOT/scripts/cleanup.sh" "$@"
            ;;
        status)
            print_info "使用旧系统命名约定检查状态"
            export USE_LEGACY_NAMING=true
            "$PROJECT_ROOT/scripts/utils/check-resources.sh" "$@"
            ;;
        *)
            print_error "旧系统不支持命令: $command"
            return 1
            ;;
    esac
}

route_to_new() {
    local command="$1"
    shift
    
    "$PROJECT_ROOT/scripts/cli/datalake" "$command" "$@"
}

# =============================================================================
# 主函数
# =============================================================================

show_help() {
    cat << EOF
数据湖兼容性CLI v$COMPAT_CLI_VERSION

此工具自动检测并路由到适当的系统（新/旧）

用法: datalake-compat [命令] [选项]

系统命令:
  mode              显示当前系统模式（new/legacy）
  migrate           执行到新系统的迁移
  switch [mode]     切换到指定模式（new/legacy）
  
数据湖命令:
  deploy            部署数据湖
  destroy           删除数据湖
  status            检查状态
  
选项:
  --force-new       强制使用新系统
  --force-legacy    强制使用旧系统
  -h, --help        显示帮助

示例:
  datalake-compat mode           # 查看当前模式
  datalake-compat deploy         # 自动选择系统部署
  datalake-compat migrate        # 迁移到新系统
EOF
}

main() {
    local force_mode=""
    local command=""
    local args=()
    
    # 解析参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            --force-new)
                force_mode="new"
                shift
                ;;
            --force-legacy)
                force_mode="legacy"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            mode|migrate|switch|deploy|destroy|status|cleanup)
                if [[ -z "$command" ]]; then
                    command="$1"
                else
                    args+=("$1")
                fi
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ -z "$command" ]]; then
        show_help
        exit 0
    fi
    
    # 加载配置
    load_config
    
    # 确定系统模式
    local system_mode
    if [[ -n "$force_mode" ]]; then
        system_mode="$force_mode"
    else
        system_mode=$(detect_system_mode)
    fi
    
    print_debug "系统模式: $system_mode"
    
    # 处理特殊命令
    case "$command" in
        mode)
            echo "当前系统模式: $system_mode"
            if [[ "$system_mode" == "legacy" ]]; then
                print_warning "建议迁移到新的模块化系统"
                print_info "运行 'datalake-compat migrate' 开始迁移"
            fi
            exit 0
            ;;
        migrate)
            if [[ "$system_mode" == "new" && -z "$force_mode" ]]; then
                print_info "系统已经在使用新模式"
                exit 0
            fi
            exec "$PROJECT_ROOT/scripts/migrate-to-modular.sh" "${args[@]}"
            ;;
        switch)
            if [[ ${#args[@]} -eq 0 ]]; then
                print_error "请指定目标模式: new 或 legacy"
                exit 1
            fi
            
            local target_mode="${args[0]}"
            if [[ "$target_mode" != "new" && "$target_mode" != "legacy" ]]; then
                print_error "无效的模式: $target_mode (可选: new, legacy)"
                exit 1
            fi
            
            # 更新配置文件
            if [[ "$target_mode" == "legacy" ]]; then
                echo "USE_LEGACY_NAMING=true" >> "$PROJECT_ROOT/configs/config.env"
                print_success "已切换到旧系统模式"
            else
                sed -i.bak '/USE_LEGACY_NAMING/d' "$PROJECT_ROOT/configs/config.env" || true
                print_success "已切换到新系统模式"
            fi
            exit 0
            ;;
    esac
    
    # 路由到适当的系统
    if [[ "$system_mode" == "legacy" ]]; then
        print_info "使用旧系统处理命令: $command"
        route_to_legacy "$command" "${args[@]}"
    else
        print_info "使用新系统处理命令: $command"
        route_to_new "$command" "${args[@]}"
    fi
}

# 执行主函数
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi